# 区块链抽象与互操作性 2.0

原文链接：[Blockchain Abstraction and Interoperability 2.0](https://talk.nervos.org/t/blockchain-abstraction-and-interoperability-2-0/5440)

原文作者：Jan Xie

2009 年比特币诞生后不久，我们迎来了一个所谓的 “比特币替代品” （altcoin）的时代，在这个时代里，人们尝试各种想法来扩展比特币。数千种加密货币被创造出来。一些比特币替代币幸存了下来，而另一些则消失了。这其中最成功的当属以太坊。那么为什么是以太坊呢？在以太坊之前，每次提出一个新的区块链应用程序时，都会创建一个新的 “替代币” 来实现这个特定的应用程序。而以太坊结束了这种繁琐的发展方式，并引入了一个通用编程模型，允许开发人员在链上搭建任何去中心化的应用程序。以太坊将开发者从建立共识和 p2p 网络的负担中解放出来，并赋予开发者将宝贵时间分配给业务逻辑的特权。以太坊就像 iPhone 和它的[功能手机前辈](https://en.wikipedia.org/wiki/Feature_phone)之间的比较一样（降维打击），给我们带来了 DApps 的寒武纪大爆发。

回顾过去，以太坊已经成长为最有价值的区块链，因为它系统地解决了数千个问题，而其他的区块链一次只试图解决一个问题。以太坊通过在不同的层次上问问题提供了一个系统的解决方案——而不是思考如何构建下一个爆款的应用程序，以太坊追求的是如何使构建接下来的 10000 个应用程序变得更容易——有没有比 “一个应用一个区块链” 更好的方法？即对那些 “比特币替代币” 进行[降维打击](https://en.wikipedia.org/wiki/Death%27s_End)，这将导致一个新时代的诞生——以太坊时代。去中心化应用程序开发的成本大大降低，DApps 领域爆发了。今天，几乎所有去中心化的应用程序都依托于以太坊，它们使以太坊比任何其他 “比特币替代币” 都更强大。

一个经常被问到的问题是，以太坊是否是区块链的最终形式，或者是否会有一个区块链 X 对于以太坊来说就像以太坊对于比特币一样？下一个时代会是什么样子？

## 区块链的抽象

以太坊的关键突破是一个通用编程模型（或智能合约模型，在本文中两者概念可互换），它由 EVM 和 Account 模型组成，开发人员可以在其上实现各种应用逻辑。智能合约模型是一个中间层，它将开发人员从不必要的底层区块链细节中隔离出来，并为开发人员提供了高度的编程灵活性。以太坊所做的是[抽象，正如维基百科上](https://en.wikipedia.org/wiki/Abstraction_(computer_science))所定义的：

> 在软件工程和计算机科学中，抽象是:
>
> - 在对物体或系统的研究中去掉物理的、空间的或时间的细节或属性，以便把注意力集中在更重要的细节上的过程；这在本质上与一般化的过程相似；
> - 抽象概念的产生——通过镜像各种非抽象对象或研究系统的共同特征或属性而产生的对象——这就是抽象过程的结果。

从这个角度来看，**以太坊是比特币和 “比特币替代币” 的抽象**。抽象是系统演化的永恒主题，已经被反复多次。在编程的早期，我们编写汇编代码，后来我们创建了高级语言和编译器，使我们从繁琐的机器语言中解放出来，专注于更重要的问题。一开始，我们需要在自己的程序中直接管理硬件资源，后来我们构建操作系统作为中间层，并将那些繁重的任务委托给它们，然后我们添加硬件虚拟化，现在的应用程序都是运行在云上。Internet 的初期只有几个协议层，如 TCP/IP ，然后是应用层，我们得到 HTTP ， FTP ， SMTP 等。如你所见，随处可见这样的例子。

这就是为什么我认为**新的抽象是进化的标志，下一代区块链必须比它的前辈更加抽象**。比特币到以太坊的飞跃是区块链的第一个抽象，我相信它不会是最后一个。至于后以太坊时代可能会是什么样子，人们首先应该考虑**从以太坊进一步可以抽象出来什么**。

## 新的抽象

以太坊的通用智能合约模型相比比特币向前迈进了一步。进一步抽象的其中一个方向是基于以太坊呈现的内容创建一个更抽象的区块链。随着我们深入研究以太坊模型，我们可以发现其中嵌入了许多特定的设计选择。以下是一些最突出的例子:

1. 账户地址。用户需要一个 EOA （外部帐户）来发起交易。 EOA 地址是公钥的 Keccak256 哈希值。
2. 发送方身份验证。以太坊使用两种特定的加密算法 Secp256k1 和 Keccak256 对交易的发送者进行身份验证。
   为了创建一个有效的以太坊交易，客户端（例如钱包）必须实现 Secp256k1 和 Keccak256 来签署交易。这还意味着客户端需要一种安全的方式来管理 Secp256k1 密钥对。
3. 密码学原语（在应用程序中基本用作构建区块的算法）。以太坊的虚拟机 EVM 为了方便开发人员在其中硬编码了几个密码学原语，作为预编译，如 ECDSA 签名验证和 SHA256 哈希函数。硬编码的预编译要比在 Solidity 中实现相同的算法更加高效，因此这个措施是有现实意义的。
4. 世界状态结构。以太坊的世界状态被构建为一个巨大的默克尔-帕特丽夏树（MPT），账户为叶子节点。每个帐户还以 MPT 的形式维护自己的键值存储。 MPT 是许多可验证的数据结构之一。

这些技术选择对于非技术用户来说非常深奥，但没有什么比共识算法或经济参数的选择更重要了。这些选择影响以太坊的各个方面，就像[普朗克常数](https://en.wikipedia.org/wiki/Planck_constant)的一个小调整可能就会[彻底改变我们的宇宙](https://iopscience.iop.org/article/10.1088/0143-0807/37/5/055406/meta)。构建一个新的去中心化生态系统就像是创造一个新的宇宙，而这些设计选择就像是嵌入那个宇宙中的物理规则。

这些设计选择是为了帮助以太坊实现其最初的目标，但它们也许并非最好的选择。例如，发送方身份验证选择的算法是 secp256k1 ，这对于设计人员来说很方便，但是对于在[不支持 secp256k1 的环境](https://crypto.stackexchange.com/questions/85831/what-ec-curve-is-used-by-apple-ios-platform)中使用以太坊造成了不必要的障碍。所选择的预编译程序是一个小的白名单，它基本上忽略了今天最广泛使用的原语。在状态结构中使用的 MPT 被证明是[非常低效的](https://hackernoon.com/getting-deep-into-geth-why-syncing-ethereum-node-is-slow-1edb04f9dc5)，[加剧了状态爆炸问题](https://blog.ethereum.org/2021/03/03/geth-v1-10-0/)，并导致了与 IO 相关的 [EVM 操作码的定价困难](https://eips.ethereum.org/EIPS/eip-1884)，而错误的定价可能导致安全问题，如 DoS 攻击。

以太坊社区和其他新项目也注意到了这些问题，并尝试了不同的解决方案。例如，以太坊增加了有用的预编译，并通过一系列硬分叉重新定价操作码， Tezos 增加了对 secp256r1 的支持，用于发送者身份验证等等。问题是，这与我们在 “比特币替代币” 时代处理应用程序需求的方式类似。此外，这些设计决策可能比应用程序更复杂，而且通常，没有最佳的解决方案存在，我们可能会在不同的情况下选择不同的选项。即使今天确实有最佳选择，也不能保证明天该方案仍然是最好的。因此，一个更好的解决方案是在不同的层次上思考——而不是通过核心团队协调的硬分叉添加新特性，**那么我们可以通过创建新的抽象，让智能合约开发人员做他们想做的事情吗?**

[Nervos CKB 回答了这个问题，并在一个新的层次创造了一个新的抽象](https://medium.com/nervosnetwork/a-tale-of-abstractions-the-quest-for-better-ckb-developer-tools-550aed756a91)。例如， CKB 事务是抽象的，其中用户和开发人员不受默认的 blake2b-secp256k1 身份验证的限制，任何人都可以用 blake2b-secp256r1 、 keccak256-ed25519 或 blake2b-sha3-schnorr 替换它1。
CKB-VM是抽象的，其中没有预编译，即使缺省的加密原语，如散列函数blake2b和签名验证secp256k1，也只是运行在虚拟机中的智能合约。
它们运行在与应用程序开发人员创建的智能合约相同的环境中，没有特殊权限。
单元模型是抽象的，其中单元只是存储，没有任何内部结构，其布局完全留给开发人员，正如我们在sUDT和xUDT中看到的那样。
由于CKB在许多方面是抽象的，开发人员被赋予了更大的自由和新的能力。
CKB是以太坊的抽象，正如以太坊是比特币的抽象一样。
抽象使CKB成为更简单但更强大的区块链，并将大部分工作转移到链外，其中一些工作将在第2层完成。
比特币的抽象将开发人员分为区块链开发人员(负责底层区块链)和智能合约开发人员(负责构建应用程序)。
以太坊的抽象将智能合约开发人员分为系统合约开发人员和应用合约开发人员，前者将专注于系统级智能合约，如加密原语、锁定脚本，甚至内存管理模块。

最近，以太坊社区已经认识到了抽象的重要性。
如果成功了，我认为它会让以太坊比现在更加抽象，让它比那些无法跟上的人更有优势。
然而，我也怀疑诸如account抽象之类的提议能否达到与CKB相同的抽象水平，因为要对运行中的生态系统进行彻底的改变是极其困难的，就像调整普朗克常数而不破坏宇宙是不可能的一样。
例如，帐户抽象将给事务池等关键模块引入新的安全复杂性，因为每次签名新事务时，验证器将需要处理任意的计算，而不是固定的签名验证。

抽象的另一个方向是可伸缩性。
分片和第2层解决方案都有一个共同的问题——它们以某种方式改变了应用程序的开发。
例如，处理跨分片调用或跨二层事务可能与处理第1层上的契约调用完全不同。
第2层应用程序开发人员还可能在不同的层上面对不同的智能合约模型(例如UTXO-model第2层链在Account model第1层之上，或者反之亦然)。
如何隐藏这些细节并为应用程序开发人员提供流畅的体验，就好像他们是在第1层上构建的一样，这仍然是一个悬而未决的问题。
这是我们正在积极努力解决的具有挑战性的问题之一。
CKB上的第一个通道建设，通用支付通道2，就是这种思路下的一个例子。
GPC的目标是为第1层的UDT提供一个“透明的”可伸缩性层，这样任何UDT都可以从第一天就被渠化，而不需要开发人员做任何额外的努力。
在GPC中，我们从UDT开发者那里抽象出了支付通道协议的细节。
我们在godwake和Polyjuice上的工作可以找到另一种尝试，它可以被认为是在CKB之上的计算和可伸缩性抽象。