# 区块链抽象与互操作性 2.0

原文链接：[Blockchain Abstraction and Interoperability 2.0](https://talk.nervos.org/t/blockchain-abstraction-and-interoperability-2-0/5440)

原文作者：Jan Xie

2009 年比特币诞生后不久，我们迎来了一个所谓的 “比特币替代品” （altcoin）的时代，在这个时代里，人们尝试各种想法来扩展比特币。数千种加密货币被创造出来。一些比特币替代币幸存了下来，而另一些则消失了。这其中最成功的当属以太坊。那么为什么是以太坊呢？在以太坊之前，每次提出一个新的区块链应用程序时，都会创建一个新的 “替代币” 来实现这个特定的应用程序。而以太坊结束了这种繁琐的发展方式，并引入了一个通用编程模型，允许开发人员在链上搭建任何去中心化的应用程序。以太坊将开发者从建立共识和 p2p 网络的负担中解放出来，并赋予开发者将宝贵时间分配给业务逻辑的特权。以太坊就像 iPhone 和它的[功能手机前辈](https://en.wikipedia.org/wiki/Feature_phone)之间的比较一样（降维打击），给我们带来了 DApps 的寒武纪大爆发。

回顾过去，以太坊已经成长为最有价值的区块链，因为它系统地解决了数千个问题，而其他的区块链一次只试图解决一个问题。以太坊通过在不同的层次上问问题提供了一个系统的解决方案——而不是思考如何构建下一个爆款的应用程序，以太坊追求的是如何使构建接下来的 10000 个应用程序变得更容易——有没有比 “一个应用一个区块链” 更好的方法？即对那些 “比特币替代币” 进行[降维打击](https://en.wikipedia.org/wiki/Death%27s_End)，这将导致一个新时代的诞生——以太坊时代。去中心化应用程序开发的成本大大降低，DApps 领域爆发了。今天，几乎所有去中心化的应用程序都依托于以太坊，它们使以太坊比任何其他 “比特币替代币” 都更强大。

一个经常被问到的问题是，以太坊是否是区块链的最终形式，或者是否会有一个区块链 X 对于以太坊来说就像以太坊对于比特币一样？下一个时代会是什么样子？

## 区块链的抽象

以太坊的关键突破是一个通用编程模型（或智能合约模型，在本文中两者概念可互换），它由 EVM 和 Account 模型组成，开发人员可以在其上实现各种应用逻辑。智能合约模型是一个中间层，它将开发人员从不必要的底层区块链细节中隔离出来，并为开发人员提供了高度的编程灵活性。以太坊所做的是[抽象，正如维基百科上](https://en.wikipedia.org/wiki/Abstraction_(computer_science))所定义的：

> 在软件工程和计算机科学中，抽象是:
>
> - 在对物体或系统的研究中去掉物理的、空间的或时间的细节或属性，以便把注意力集中在更重要的细节上的过程；这在本质上与一般化的过程相似；
> - 抽象概念的产生——通过镜像各种非抽象对象或研究系统的共同特征或属性而产生的对象——这就是抽象过程的结果。

从这个角度来看，**以太坊是比特币和 “比特币替代币” 的抽象**。抽象是系统演化的永恒主题，已经被反复多次。在编程的早期，我们编写汇编代码，后来我们创建了高级语言和编译器，使我们从繁琐的机器语言中解放出来，专注于更重要的问题。一开始，我们需要在自己的程序中直接管理硬件资源，后来我们构建操作系统作为中间层，并将那些繁重的任务委托给它们，然后我们添加硬件虚拟化，现在的应用程序都是运行在云上。Internet 的初期只有几个协议层，如 TCP/IP ，然后是应用层，我们得到 HTTP ， FTP ， SMTP 等。如你所见，随处可见这样的例子。

这就是为什么我认为**新的抽象是进化的标志，下一代区块链必须比它的前辈更加抽象**。比特币到以太坊的飞跃是区块链的第一个抽象，我相信它不会是最后一个。至于后以太坊时代可能会是什么样子，人们首先应该考虑**从以太坊进一步可以抽象出来什么**。

## 新的抽象

以太坊的通用智能合约模型相比比特币向前迈进了一步。进一步抽象的其中一个方向是基于以太坊呈现的内容创建一个更抽象的区块链。随着我们深入研究以太坊模型，我们可以发现其中嵌入了许多特定的设计选择。以下是一些最突出的例子:

1. 账户地址。用户需要一个 EOA （外部帐户）来发起交易。 EOA 地址是公钥的 Keccak256 哈希值。
2. 发送方身份验证。以太坊使用两种特定的加密算法 Secp256k1 和 Keccak256 对交易的发送者进行身份验证。
   为了创建一个有效的以太坊交易，客户端（例如钱包）必须实现 Secp256k1 和 Keccak256 来签署交易。这还意味着客户端需要一种安全的方式来管理 Secp256k1 密钥对。
3. 密码学原语（在应用程序中基本用作构建区块的算法）。以太坊的虚拟机 EVM 为了方便开发人员在其中硬编码了几个密码学原语，作为预编译，如 ECDSA 签名验证和 SHA256 哈希函数。硬编码的预编译要比在 Solidity 中实现相同的算法更加高效，因此这个措施是有现实意义的。
4. 世界状态结构。以太坊的世界状态被构建为一个巨大的默克尔-帕特丽夏树（MPT），账户为叶子节点。每个帐户还以 MPT 的形式维护自己的键值存储。 MPT 是许多可验证的数据结构之一。

这些技术选择对于非技术用户来说非常深奥，但没有什么比共识算法或经济参数的选择更重要了。这些选择影响以太坊的各个方面，就像[普朗克常数](https://en.wikipedia.org/wiki/Planck_constant)的一个小调整可能就会[彻底改变我们的宇宙](https://iopscience.iop.org/article/10.1088/0143-0807/37/5/055406/meta)。构建一个新的去中心化生态系统就像是创造一个新的宇宙，而这些设计选择就像是嵌入那个宇宙中的物理规则。

这些设计选择是为了帮助以太坊实现其最初的目标，但它们也许并非最好的选择。例如，发送方身份验证选择的算法是 secp256k1 ，这对于设计人员来说很方便，但是对于在[不支持 secp256k1 的环境](https://crypto.stackexchange.com/questions/85831/what-ec-curve-is-used-by-apple-ios-platform)中使用以太坊造成了不必要的障碍。所选择的预编译程序是一个小的白名单，它基本上忽略了今天最广泛使用的原语。在状态结构中使用的 MPT 被证明是[非常低效的](https://hackernoon.com/getting-deep-into-geth-why-syncing-ethereum-node-is-slow-1edb04f9dc5)，[加剧了状态爆炸问题](https://blog.ethereum.org/2021/03/03/geth-v1-10-0/)，并导致了与 IO 相关的 [EVM 操作码的定价困难](https://eips.ethereum.org/EIPS/eip-1884)，而错误的定价可能导致安全问题，如 DoS 攻击。

以太坊社区和其他新项目也注意到了这些问题，并尝试了不同的解决方案。例如，以太坊增加了有用的预编译，并通过一系列硬分叉重新定价操作码， Tezos 增加了对 secp256r1 的支持，用于发送者身份验证等等。问题是，这与我们在 “比特币替代币” 时代处理应用程序需求的方式类似。此外，这些设计决策可能比应用程序更复杂，而且通常，没有最佳的解决方案存在，我们可能会在不同的情况下选择不同的选项。即使今天确实有最佳选择，也不能保证明天该方案仍然是最好的。因此，一个更好的解决方案是在不同的层次上思考——而不是通过核心团队协调的硬分叉添加新特性，**那么我们可以通过创建新的抽象，让智能合约开发人员做他们想做的事情吗?**

[Nervos CKB 回答了这个问题，并在一个新的层次创造了一个新的抽象](https://medium.com/nervosnetwork/a-tale-of-abstractions-the-quest-for-better-ckb-developer-tools-550aed756a91)。例如， CKB 事务是抽象的，其中用户和开发人员不受默认的 blake2b-secp256k1 身份验证的限制，任何人都可以用 blake2b-secp256r1 、 keccak256-ed25519 或 blake2b-sha3-schnorr [替换它](https://talk.nervos.org/t/lay2-pw-sdk-build-dapps-on-ckb-and-run-them-everywhere/4289)。CKB-VM 是没有任何预编译的抽象形式，即使是默认的密码学原语，如散列函数 blake2b 和签名验证所用的 secp256k1 ，也只是运行在虚拟机中的智能合约。它们运行在与应用程序开发人员创建的智能合约相同的环境中，没有特殊权限。Cell 模型是抽象的，其中 Cell 只是一个没有任何内部结构的存储单元，其布局完全留给开发人员，正如我们在 [sUDT](https://talk.nervos.org/t/rfc-simple-udt-draft-spec/4333) 和 [xUDT](https://talk.nervos.org/t/rfc-extensible-udt/5337) 中看到的那样。由于 CKB 在许多方面是抽象的，开发人员被赋予了更大的自由和更多的能力（去做二次开发）。**CKB是以太坊的抽象，正如以太坊是比特币的抽象一样。** 抽象使 CKB 成为一个更简单但更强大的区块链，并将大部分工作转移到链下，其中一些工作将在 layer 2 中完成。比特币的抽象将开发人员分为区块链开发人员(负责底层区块链)和智能合约开发人员(负责构建应用程序)。以太坊的抽象将智能合约开发人员分为系统合约开发人员和应用合约开发人员，前者将专注于系统级智能合约，如密码学原语、锁定脚本，甚至内存管理模块。

[最近，以太坊社区已经认识到了抽象的重要性](https://hackmd.io/@SamWilsn/ryhxoGp4D)。如果成功了，我认为它会让以太坊比现在更加抽象，让它比那些无法跟上的人更有优势。然而，我也怀疑诸如 account 抽象之类的提议能否达到与 CKB 相同的抽象水平，因为要对运行中的生态系统进行彻底的改变是极其困难的，就如同调整普朗克常数而不破坏宇宙是不可能的一样。例如，帐户抽象将给交易池等关键模块引入新的安全复杂性，因为每次对新交易进行签名时，验证人需要有处理任意计算的能力，而不是固定的签名验证。

抽象的另一个方向是扩展性。分片和 layer 2 的解决方案都有一个共同的问题———它们以某种方式改变了应用程序的开发。例如，处理[跨分片调用](https://ethresear.ch/t/cross-shard-defi-composability/6268)或跨 layer 2 的交易可能与处理 layer 1 上的合约调用完全不同。layer 2 应用程序开发人员还可能在不同的层上面对不同的智能合约模型（例如在一个一层的 Account 模型区块链上层实现一个二层的 UTXO 模型区块链，或者反之亦然）。如何隐藏这些细节并为应用程序开发人员提供流畅的体验，就好像他们是在 layer 1 上开发一样，这仍然是一个悬而未决的问题。这是我们正在积极努力解决的具有挑战性的问题之一。我们在 CKB 上的实现的第一个通道应用程序，[通用支付通道（GPC）](https://talk.nervos.org/t/a-generic-payment-channel-construction-and-its-composability/4697)，就是这种思路下的一个例子。GPC 的目标是为 layer 1 的 UDT 提供一个 “透明的” 扩展层，这样任何 UDT 都可以从一开始就通道化，而不需要开发人员做任何额外的努力。在 GPC 中，我们从 UDT 开发者那里抽象出了支付通道协议的细节。我们在 [Godwake 和 Polyjuice](https://medium.com/nervosnetwork/towards-ckb-style-lego-pieces-polyjuice-on-godwoken-cbc935d77abf) 上可以找到另一种尝试的方案，它可以被认为是在 CKB 之上的计算和扩展性的抽象。

## 互操作性 2.0

每一次区块链的抽象都会给我们带来一些新东西，一些我们在以前的抽象中从未见过的东西。第一个区块链的抽象为我们提供了通用的可编程性和相互连接的去中心化应用程序，那么下一次区块链的抽象将给我们带来什么?

互操作性2.0(在[这里](https://blockcast.cc/news/nervos-xie-hanjian-interoperability-2-0-allows-users-to-enter-the-blockchain-from-any-entry/)首先提到的概念)将会成为在新的抽象中成长起来的丰硕果实。我们设想一个拥有多个无许可区块链、可许可区块链和中心化系统的数字经济未来。互操作性允许数字资产在这些独立系统之间转移和交互地调用智能合约。近年来，人们对[互操作性](https://docs.keep.network/tbtc/index.pdf)[进行](https://docs.zkproof.org/pages/standards/accepted-workshop3/proposal-plumo_celolightclient.pdf)了[大量](https://www.r3.com/wp-content/uploads/2017/06/chain_interoperability_r3.pdf)的[研究](https://spiral.imperial.ac.uk/bitstream/10044/1/75810/6/2019-1128.pdf)，认为可以用一系列基本的原语来解决互操作性问题，如多签公证、中继和哈希锁定。

尽管区块链互操作性在今天的技术上是可能的，但在技术可行性和实现无缝互操作性的数字经济之间还有其他缺失的部分。首先，我们的互操作性计划只会产生更多的分裂网络。像Polkadot和Cosmos这样的项目已经定义了各自的标准，并试图围绕自己的“中心”建立一个多链网络。同时也在努力直接搭建比特币和以太坊之间的桥梁。不可思议的是，在未来的某个时候，这些独立网络的核心团队和社区能够坐到谈判桌前，就一个通用的互操作性标准达成一致。第二，但更重要的是，即使这些区块链网络是完美的互操作，糟糕的互操作用户体验仍然会阻止用户使用它们。从用户的角度来看，如果我是一个比特币用户，想要将我的比特币转移到以太坊以参与DeFi应用程序，我必须首先运行我的比特币钱包，然后跨链，然后使用一个单独的以太坊钱包。为了完成这样的跨链操作，我必须安装两个钱包应用程序，保留两套助记符并使用两个地址。这个过程本身是非常难以控制的，只适用于两条链。随着用户想要与更多的区块链交互，他们需要管理的助记符/地址/密钥对就越多。这种用户体验问题不仅阻碍了dapp的采用，也破坏了去中心化，这是区块链的核心价值，因为用户将被迫依赖集中的托管服务，以避免所有的麻烦。

解决这两个问题需要一种新的互操作性，我们称之为互操作性2.0。具有这种新的互操作性的区块链将像一个“通用中心”，可以与任何其他区块链交互而不被其他区块链注意到。一个“通用中心”必须能够理解和执行其他区块链的协议，而不是发明自己的协议并要求其他人学习。一个通用中心将类似于一个会说其他语言的多语言个体，因此中心可以与每个人交谈，每个人都愿意与中心对话。在加密世界中，所有协议(区块链使用的语言)都由密码学组成，这意味着这样一个通用中心必须支持我们今天和明天将看到的区块链中使用的广泛的加密原语。通用中心必须能够理解各种区块链钱包签署的交易，允许用户坚持使用一个单一的钱包，同时能够使用在通用中心上运行的任何应用程序。
